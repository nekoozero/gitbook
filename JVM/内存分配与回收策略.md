# 内存分配与回收策略

> 时间：2020/3/19

最根本的目标是自动化解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。

## 对象优先在 Eden 分配

对象在新生代`Eden`区中分配。当`Eden`区没有足够空间进行分配时，虚拟机将发起一次`minor GC`。

`-XX:+PrintGCDetails`告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存区域分配情况。

## 大对象直接进入老年代

避免大对象的原因是：在分配空间时，它容易导致内存明明还有不少空间时就提前出发垃圾收集，以获取足够的连续空间才能安置好它们，而复制对象的时候，大对象就意味着高额的内存复制开销。提供了`-XX:PertenureSizeThreshold`参数，指定大于该设置值的对象直接在老年代分配，防止在`Eden`和`Survivor`来回复制，产生大量内存复制操作。

该参数只对`Serial`和`ParNew`两款新生代收集器有效，`parallel Scavenge`并不支持这个参数，可以使用`CMS`和`ParNew`的收集器组合。

## 长期存活的对象进入老年代

虚拟机给每个对象定义了一个对象年龄计数器，存储在**对象头**中，对象通常在`Eden`区诞生，如果经过第一次`Minor GC`后仍然存活，并且能够被`Survivor`容纳的话，该对象会被移动到`Survivor`中，并将其对象年龄设置成1岁。对象在`Survovir`中每熬过一次`Minor GC`，年龄就增加一岁，年龄增加到一定程度（默认15），就会被晋升到老年代中。晋升的阈值可以通过参数`-XX:MaxTenuringThreshold`来设置。

## 动态对象年龄判定

虚拟机并不是要求对象的年龄必须达到`-XX:MaxTenuringThreshold`才能晋升老年代，**如果在`Survivor`空间中相同年龄所有对象的大小总和大于`Survivor`空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代，无需等到`-XX:MaxTenuringThreshold`中要求的年龄**。

## 空间分配担保

在发生`Minor GC`之前，虚拟机要先检查老年代最大可用的连续空间是否大于新生代所有对象和总空间，如果这个条件成立，那这一次`Minor GC`可以确保是安全的。如果不成立，虚拟机会先查看`-XX:HandlePromotionFailure`参数设置值是否允许担保失败。

如果允许担保失败，那么就会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次`Minor GC`，尽管这次`GC`是有风险的。

如果小于或者不允许担保，那么会直接进行一次`Full GC`。

> 风险是指新生代使用清除-复制算法，有可能在`Minor GC`之后还有大量对象存活，这些对象`Survivor`容不下，只能直接送入老年代。如果担保失败了吗，只能发起一次`Full GC`。

`JDK6`之后，`-XX:HandlePromotionFailure`参数不会影响到虚拟机的空间分配担保策略。只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行`Minor GC`，否则将进行`Full GC`。