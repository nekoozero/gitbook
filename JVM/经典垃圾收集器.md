# 经典垃圾收集器

> 2020/3/18

## 基本概念

1. 并行：多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在工作，用户线程默认是处于等待状态的。
2. 并发：垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行，此时应用程序的处理的吞吐量将受到一定影响。

![8acc580aa08b3d2051dad2e3d26fdeaa.jpg](http://www.qxnekoo.cn:8888/images/2020/03/16/8acc580aa08b3d2051dad2e3d26fdeaa.jpg)

## Serial 收集器（新生代）

是一个单线程工作的收集器，不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束

![Serial.jpg](http://www.qxnekoo.cn:8888/images/2020/03/16/Serial.jpg)

对运行在客户端模式下的虚拟机来说是一个很好的选择。

## ParNEW 收集器（新生代）

是`Serial`收集器的多线程并行版本

![ParNew.jpg](http://www.qxnekoo.cn:8888/images/2020/03/16/ParNew.jpg)

支持多线程并行收集，除了`Serial`收集器外，目前只有它能与`CMS`收集器配合工作，但从`JDK9`开始，`ParNew`和`CMS`收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。而且取消了 `-XX:+UseParNewGC`参数，意味着`ParNew`和`CMS`只能相互搭配使用，再也没有其他收集器和它们配合，可以理解为`ParNew`合并进入`CMS`，成为它专门处理新生代的组成部分。

## CMS 收集器（老年代）

是一种以获取最短回收停顿时间为目标的收集器，使用的是**标记-清除**算法，经常适用于互联网网站和基于浏览器的`B/S`系统的服务器上，这类应用通常会关注服务的响应速度，希望系统停顿时间尽可能短。

第一款真正意义上支持并发的垃圾收集器，首次实现了让垃圾收集线程与用户线程（基本上）同时工作。分为四个步骤：

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

![CMS.png](http://www.qxnekoo.cn:8888/images/2020/03/16/CMS.png)

主要优点：并发收集、低停顿

缺点：

1. 占用系统资源，降低总吞吐量
2. 无法处理“浮动垃圾”，主要是并发标记和并发清理阶段，程序还在运行，自然伴随着新的垃圾对象产生。如果垃圾收集阶段无法给用户线程提供足够的内存空间，会触发“并发失败（`Current Mode Failure`）”。启动预备方案，临时启用`Serial Old`收集器来重新进行老年代的垃圾收集，这样停顿时间就更长了。
3. 使用标记-清除算法，导致收集结束后有空间碎片产生，会给分配大对象带来麻烦。`CMS`提供了`-XX:+UseCMSCompactAtFullCollection`(默认是开启的，此参数从`JDK9`废弃)，用于在`CMS`收集器不得不进行`Full GC`时开启内存碎片整理合并过程，但涉及到移动对象，无法并发，空间碎片问题解决了，但是停顿时间会变长。又提供一个参数`-XXL:CMSFullGCsBeforeCompaction`(此参数从`JDK9`废弃)，表示在若干次不整理空间的`Full GC`之后，下一次进入`Full GC`前会先进行碎片整理（默认值为0，表示每次进入`Full GC`前都进行碎片整理）。

## Parallel Scavenge 收集器（新生代）

是一款新生代收集器，基于标记-复制算法，能够并行收集的多线程收集器。和其他收集器不同，`CMS`关注尽可能的缩短垃圾收集时用户线程的停顿时间，而`Parallel Scavenge`收集器的目标则是达到一个**可控制的吞吐量（处理器用于运行用户代码的时间与处理器总消耗时间的比值）**。

> 停顿时间短适合需要与用户交互或者保证服务响应的质量，良好的相应速度能提升用户体验；而高吞吐量则可以高效率地利用处理器资源，尽快完成程序的运算任务，适合于在后台运算而交互不多的场景。

控制吞吐量的两个参数`-XX:MaxGCPauseMillis`(控制最大垃圾收集停顿时间)、`-XX:GCTimeRatio`(直接设置吞吐量大小)，不要把停顿时间设的太小，主要是以牺牲吞吐量和新生代空间为代价的，会导致垃圾收集频繁。停顿时间会下降，但吞吐量也会下降。

示意图和`parallel Old`一样。

### 自适应调节策略

`-XX:+UseAdaptiveSizePolicy`，是一个开关，当这个参数被激活的时候，不需要人工指定新生代大小、`Eden`和`Survivor`比例、晋升老年代对象的大小等细节参数了，虚拟机会根据系统运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

它也是和`ParNew`收集器区别之一。

## Serial Old 收集器（标记-整理）

是`Serial`收集器的老年代版本，单线程收集器，使用标记-整理算法。

在客户端模式中可以使用。

在服务端模式下，有两种用途：

1. 在`JDK 5`之前的版本中与`Parallel Scavenge`收集器搭配使用。
2. 在`CMS`收集器失败时（“并发失败”）的后备方案。

示意图和`Serial`收集器一样

## Parallel Old 收集器（标记-整理）

是`Parallel Scavenge`收集器的老年代版本，支持多线程并发收集，基于标记-整理算法。在`JDK6`提供，至此，“吞吐量优先”收集器有了名副其实的搭配，在注重吞吐量或处理器资源不足的情况下，可以考虑使用`Parallel Old`和`Parallel Scavenge`收集器这个组合。

![Parallel-OldParallel-Scavenge.jpg](http://www.qxnekoo.cn:8888/images/2020/03/16/Parallel-OldParallel-Scavenge.jpg)

## Garbage First 收集器（重点）

也成为`G1`收集器，**开创了收集器面向局部收集的设计思路和基于`Region`的内存布局形式**。之前所有的垃圾收集器包括`CMS`，垃圾收集的目标要么是整个新生代（`Minor GC`），要么是这个老年代（`Major GC`），要么就是整个堆（`Full GC`）,`G1`则跳出了这个模式。想要建立起“**停顿时间模型**”的垃圾收集器，也就是能够支持指定在一个长度为`M`毫米的时间片段内，消耗在垃圾收集上的时间大概率不超过`N`毫秒这样的目标。

`G1`提供并发的类卸载功能的支持，是一款主要面向服务器应用的垃圾收集器，期望可以替换掉`CMS`收集器。`JDK9`中`G1`取代了`Parallel Scavnege`和`Parallel Old`组合，称为服务端模式下默认的垃圾收集器，而`CMS`则已不被推荐了。

`G1`可以面向对内存的任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是`G1`收集器的`Mixed GC`模式。

其开创的基于`Region`的内存布局是实现整个目标的关键，虽然仍是遵循分代收集理论设计的，但和其他收集器有着明显的差别。

> 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的`Java`推划分为多个大小相等的独立区域(`Region`)，每一个`Region`都可以根据需要，扮演新生代的`Eden`空间、`Survivor`空间，或者老年代空间。收集器能够对扮演不同角色的`Region`采用不同的策略去处理。新生代、老年代都是一系列（不需要连续）的动态集合。

`Region`中还有一类特殊的`Humongous`的区域，专门用来存储大对象。只要大小超过了一个`Region`容量一半的对象即可判定为大对象。对于超过了整个`Region`容量的超级大对象，将会存放在`N`个连续的`Humongous Region`之中，`G1`的大多数行为都把`Humongous Region`作为老年代的一部分来进行看待。

之所以能够建立**可预测的停顿时间模型**，是因为将`Region`作为单词回收的最小单元，及每次收集到的内存空间都是`Region`大小的整数倍，有计划地避免在整个`Java`堆中进行全区域的垃圾收集。

具体的做法是让`G1`收集器去跟踪各个`Region`里面的垃圾堆积的“价值大小”，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户允许设定的收集停顿时间（默认200毫秒），优先处理回收价值收益最大的那些`region`,这就是`Garbage First`名字的由来。**这种使用`Region`划分内存空间，以及具有优先级的区域回收方式，保证了`G1`收集器在有限的时间内获取尽可能高的收集效率。**

可以由用户指定期望的停顿时间是很强大的一个功能，但是这个期望值必须是符合实际的。如果停顿时间太短，会导致每次回收的回收集只占堆内存很小的一部分空间，收集器的速度跟不上分配器的分配速度，导致垃圾慢慢堆积，时间长了会引发`Full GC`降低性能，一般来说设置为一两百毫秒或者两三百毫秒比较合理。（参数`-XX:MaxGCPauseMillis`,默认值200）

相比`CMS`，优点有如下：

1. 指定最大停顿时间
2. 分`Region`的内存布局
3. 按收益动态确定回收集
4. `G1`整体上来看是基于“标记-整理的算法”，但从局部上来看（两个`Region`之间）又是基于“标记-复制”算法实现，意味着运作期间不会产生空间内存碎片，垃圾收集完成之后能提供规整的可用内存，有利于程序的长时间运作。

缺点：

1. 无论是垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比`CMS`要高。
2. 处理跨代指针，`G1`卡表实现更为复杂。

