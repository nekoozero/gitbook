# JIT部分优化措施

> 时间：2020/4/15

即时编译器常见优化技术：栈上分配、公共子表达式消除、无用代码消除、自动装箱消除、逃逸分析、锁消除、锁膨胀、表达式提升、内联……

首先要明确一点的是，所做的这些优化都是建立在代码的中间表示或者是机器码之上的，绝不是直接在 `Java` 源码上去做的。

选择4个具有代表性的优化技术：

1. 最重要的优化技术之一：方法内联
2. 最前沿的优化技术之一：逃逸分析
3. 语言无关的经典优化技术之一：公共表达式消除
4. 语言相关的经典优化技术之一：数组边界检查消除

## 方法内联

戏称为优化之母，因为除了消除方法调用的成本之外，它更重要的意义是**为其他优化手段建立良好的基础**。没有内联，多数其他优化都无法有效进行。

理解起来也很简单，**不过是把目标方法的代码原封不动地复制到发起调用的方法之中，避免发生真实的方法调用而已**。但是其过程还是非常复杂的。

## 逃逸分析

基本原理：分析对象的动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸。甚至可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。

能够对不同逃逸程度的对象采用不同程度的优化：

- **栈上分配**：如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个不错的选择，对象所占用的内存将会随着栈帧出栈而销毁，垃圾收集子系统的压力会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸。

- **标量替换**：一个数据无法再分解成更小的数据来表示了，虚拟机中的基本数据类型等都不能再进一步分解了，那么这些数据就可以被称为标量。如果一个数据可以继续分解，就称为聚合量，对象就是典型的聚合量。

  **如果把一个对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程叫做标量替换。**

  将一个对象拆散，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器得到高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。

  对逃逸程度的要求更高，不允许对象逃逸出方法范围内。

- **同步消除**：如果确定一个对象不会逃逸出线程，无法被其他线程访问到，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也可以安全的消除掉。

缺点：逃逸分析的计算成本非常高，甚至不能保证带来的性能收益高于它的消耗。如果逃逸分析后发现几乎找不到不逃逸的对象，那么这些运行期耗用的时间就白白浪费了。

大神文章：

https://mp.weixin.qq.com/s/Owlhu5IFpDAyu0WYcK1EhQ

## 公共子表达式消除

如果一个表达式 `E`之前已经被计算过了，并且从先前的计算到现在 `E` 中所有变量的之都没有发生变化，那么 `E` 的这次出现就成为公共子表达。对于这种表达式，没有必要花时间对它重新计算，直接用前面的结果来代替就可以了。

理解起来还是很简单的：

`int d = (c*b)*12+a+(a+b*c)`会变成`int d = E*12+a+(a+E)`，甚至是`int d = E*13+a+a`

## 数组边界检查消除

虽然会有运行时异常 `ArrayIndexOutOfBoundsException`，但对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判断操作，这是一种性能负担。

最常见的就是在循环中，编译器只要通过数据流分析就可以判定循环变量的取值范围永远在正确的区间之内，那么在循环中就可以把整个数组的上下界检查消除掉，这就可以节省很多次的条件判断操作。



## 总结

其实优化措施还有很多，而且细讲的话也是有很多内容的，希望以后可以补充出来。