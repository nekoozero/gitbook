# 对象存活和引用

1. 那些内存需要回收？

   在`Java`内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。当方法结束或者线程结束的时候，内存自然就跟着回收了。

   而`Java`堆和方法区有着不确定性：一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，才知道会创建多少个对象。这部分内存的分配和回收是动态的。

## 对象是否已死

1. 引用计数算法
2. 可达性分析法

* 引用计数法

  在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效的时候，计数器值就减1；任何时刻，计数器为零的对象就是不可能在被使用的。

  优点：原理简单，判定效率高。

  缺点：需要配合大量额外处理才能保证正确性，因为单纯的引用计数很难解决**对象之间相互引用**的问题。

  `java`虚拟机并不是通过引用计数算法来判断对象是否存活。

* 可达性分析算法

  通过一系列称为“`GC Roots`”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，所有过程所走过的路径称为“引用链”，如果某个对象到"`GC Roots`"间没有任何引用链相连，即不可达，则证明此对象是不可能在被使用的。

  可作为`GC Roots`的对象包括：

  1. 虚拟机栈中引用的对象，各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量
  2. 在方法区中类静态属性引用的对象，譬如`Java`类的引用类型静态变量
  3. 在方法区中常量引用的对象，譬如字符串常量池里的引用
  4. 本地方法栈中`JNI`引用的对象
  5. 虚拟机内部的引用，基本数据类型对应的`class`对象，一些常驻的移仓对象，还有系统类加载器。
  6. 所有被同步锁持有的对象
  7. 反映`Java`虚拟机内部情况的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等。

## 引用

我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集中仍然非常紧张，那就可以抛弃这些对象。

`Java`中的引用：强引用、软引用、弱引用、虚引用。

* 强引用：类似`Object o = new Object()`这种关系，无论在任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
* 软引用：一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。(`SoftReference`)
* 弱引用：强度比软引用弱一些，，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，不管当前内存是否足够，都会回收掉弱引用关联的对象。(`WeakReference`)
* 虚引用：最弱的引用关系，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象实例。目的是为了这个对象在被回收时能够收到一个系统通知。（`PhantomReference`）

## 回收方法区

主要分为两个内容：**废弃常量和不再使用的类型**

1. 废弃常量

   举例：假设“`java`”字符串曾进入过字符串常量池，但是当前系统没有任何一个字符串对象的值是“`java`”,换句话说，已经没有任何字符串对象引用常量池中的“`java`”常量，且虚拟机中也没有其他地方引用这个字面量。如果这个时候发生垃圾回收，而且判断有必要的话，这个字符串就会被清除出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

2. 不再使用的类型就比较苛刻了，需要同时满足三个条件

   * 该类的所有实例已经被回收，也就是`java`堆中不存在该类及其任何派生子类的实例
   * 加载该类的类加载已被回收，这个条件除非是经过设计的可替换类加载器的场景，比如说`OSGI、JSP`的重载，否则很难达成
   * 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

在大量使用反射、动态代理、`CGLib`等字节码框架，动态生成`JSP`以及`OSGI`这类频繁自定义类加载器的场景中，通常需要`Java`虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

