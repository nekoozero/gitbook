# 类加载器

> 时间：2020/3/29

“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到虚拟机外部去实现。这个动作的代码被称为“类加载器（`Class Loader`）”

## 类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身译器共同确立其在`Java`虚拟机的唯一性每一个类加载器，都拥有一个独立的类名称空间。

也就是说比较两个类是否“相等”，必须在同一个类加载器加载的前提下才有意义，否则即使两个类来源同一个`Class`文件，被同一个虚拟机加载，只要加载它们的类加载器不同，它们就必定不相等。

## 双亲委派模型

定义：

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

`JDK8`及之前版本来介绍三层类加载器。

* 启动类加载器（`BootStrap Class Loader`）:负责加载存放在`JAVA_HOME\lib`目录，而且是虚拟机能够识别的类库加载到虚拟机的内存中。启动类加载其无法被`Java`程序直接引用，因为它是用`C++`来实现的。
* 扩展类加载器（`Extension Class Loader`）:这个加载器是以`Java`代码实现的，负责加载`JAVA_HOME\lib\ext`目录中，是一种`Java`系统类库的扩展机制，允许用户将具有通用性的类库放置在`ext`目录以扩展`Java SE` 的功能，`JDK9`之后，这种扩展机制被模块化带来的天然的扩展能力所取代。
* 应用程序类加载器（`Application Class Loader`）:也是用`Java`代码实现的，它负责加载用户类路径上所有的类库，如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序默认的类加载器。

![48634f49e381dacca0fd9f5836e50c17.png](http://www.qxnekoo.cn:8888/images/2020/03/19/48634f49e381dacca0fd9f5836e50c17.png)

`Java9`之前的应用都是由这三类加载器互相配合来完成加载的。自定义类加载器典型的有增加除了磁盘位置之外的`Class`文件来源，或者通过类加载器实现类的隔离、重载等功能。

类加载器的父子关系并不是继承的关系实现的，而是使用组合关系来复用父加载器的代码。

### 工作过程

如果一个类加载器收到了类加载的请求，他首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求，子加载器才会尝试自己去完成加载。

> 好处：`Java`中的类随着他的类加载器一起具备了一种带有优先级的层次关系。比如`java.lang.Object`，它存放在`rt.jar`中，无论哪一个类加载器要加载这个类，最终都会被委派给最顶端的启动类加载器进行加载。
>
> 可以避免类的重复加载，另外也避免了java的核心API被篡改。





> `Java9`模块化的关键目标-----可配置的封装隔离机制