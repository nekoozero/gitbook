## `HotSpot`对象

> 2020/4/9

对象在`Java`堆中的分配、布局和访问。

### 对象的创建

先进行类加载检查（没有则会执行相应的类加载过程），之后会为对象分配内存大小，**对象所需的内存大小在类加载完成后便可完全确定**。那么如何从`Java`堆中划分出等大的内存呢？

1. **指针碰撞**：假设`Java`堆中的内存是绝对规整的，所有被使用过的放在一边，未被使用过的放在另一边，中间有指针作为指示器，分配内存就是将指针向未被使用的内存空间挪动一段与对象大小相同的距离。
2. **空闲列表**：如果`Java`堆中的内存不是规整的，已被使用的和未被使用的交叉在一起，没有办法进行指针碰撞，那么虚拟机就必须维护一个列表，记录哪块内存使用的，哪块内存是未被使用的，在分配的时候找到足够大的空间给对象实例，并更新列表上的记录。

**选择哪种方式是由`Java`堆是否规整决定的，而是否规整则是由采用的垃圾收集器是否带有空间压缩整理的能力决定的。**`Serial`、`ParNew`等带压缩整理过程的收集器，系统采用得到算法时指针碰撞，而`CMS`基于清除算法的收集器，理论上只能使用空闲列表来分配内存了。

虚拟机创建对象是非常频繁的过程，即使是修改一个指针的位置，在并发的情况下也并不是线程安全的。有两种解决方案：

1. 对分配内存空间的动作进行同步处理，虚拟机是采用`CAS`配上失败重试的方式保证更新操作的原子性，但即使这样，也会影响到分配内存的效率。
2. 本地线程分配缓冲（`Thread Local Allocation Buffer,TLAB`）：内存分配的动作按照线程划分在不同的空间之中，每个线程在`Java`堆中预先分配一小块内存。虚拟机是否使用`TLAB`，通过`-XX:+UseTLAB`参数来设定。

内存分配完成之后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了`TLAB`,这一项工作也可以在`TLAB`分配时顺便进行。这一步保证了对象的实例字段在代码中可以不赋初始值就直接使用。

之后会对对象的对象头进行设置。在这些工作完成之后，一个新的对象就已经产生了，接着才是构造函数的执行等等。

![508e088fff0acbb9b824d10993991eab.png](http://www.qxnekoo.cn:8888/images/2020/04/08/508e088fff0acbb9b824d10993991eab.png)

### 对象的内存布局

对象在堆内存中的存储布局可以划分为三个部分：**对象头（`Header`）、实例数据（`Instance Data`）、对齐填充（`Padding`）。**

#### 对象头

主要分为两部分：

1. 主要用于存储**对象自身的运行时数据**，如**哈希码、`GC`分代年龄、锁状态标志、线程持有锁、偏向线程`ID`、偏向时间戳**等。这部分数据长度为32个比特或者64个比特（32位和64位的虚拟机），成为“`Mark Word`”。为了在极小的空间内存储尽量多的数据，它被设计成一个有这个动态定义的数据结构，根据对象的状态服用自己的存储空间。

   

   | 存储内容                               | 标志位 | 状态             |
   | -------------------------------------- | ------ | ---------------- |
   | 对象哈希码、对象分代年龄               | 01     | 未锁定           |
   | 指向锁记录的指针                       | 00     | 轻量级锁         |
   | 指向重量级锁的指针                     | 10     | 膨胀（重量级锁） |
   | 空、不需要记录信息                     | 11     | `GC`标记         |
   | 偏向线程`ID`、偏向时间戳、对象分代年龄 | 01     | 可偏             |

2. 另一部分是**类型指针**，对象指向它的类型元数据的指针，通过这个指针来确定该对象是哪个类的实例。

   ![HotSpot-.jpg](http://www.qxnekoo.cn:8888/images/2020/04/25/HotSpot-.jpg)

此外，如果对象是一个`Java`数组，那么**对象头中还必须有一块用于记录数组长度的数据**，因为虚拟机可以通过普通对象的元数据信息来确定普通对象的大小，但是如果数组的长度是不确定的，将无法通过元数据来推断出数组的大小。

#### 实例数据

是对象真正存储的有效信息，即在代码里面所定义的各种类型的字段内容，无论是从父类继承下来的还是在子类中定义的字段都必须记录起来。

#### 对齐填充

这并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。`HotSpot`虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，任何对象的大小都必须是8字节的整数倍。对象头部分已经被设计是8字节的倍数（1倍或2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

## 对象的访问定位

`Java`程序通过栈上的`reference`数据来操作堆上的具体对象，在虚拟机规范中只规定了他是一个指向对象的引用，并能没有定义该怎么去实现，所以对象访问方式也是由虚拟机实现而定的。主流的有两种：

1. 句柄访问，`Java`堆中可能会划分出一块内存作为句柄池，`reference`中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

   ![818f16cb57eb8a9ef198a27c1e15f95a.png](http://www.qxnekoo.cn:8888/images/2020/03/12/818f16cb57eb8a9ef198a27c1e15f95a.png)

2. 直接指针，`Java`堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，`reference`中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多多一次间接访问的开销。

   ![21d8a8b01f70ebfc6de39faa83645efd.png](http://www.qxnekoo.cn:8888/images/2020/03/12/21d8a8b01f70ebfc6de39faa83645efd.png)

> 句柄访问的好处`reference`中存储的是稳定句柄地址，在对象被移动时只会改变句柄的实例数据地址，而`reference`本身不需要被修改。
>
> 直接指针的最大好处就是速度更快，节省一次指针定位的时间开销，由于对象访问在`Java`中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。
>
> 就`HotSpot`而言，使用的第二种方式进行对象访问（也是有例外情况的）

