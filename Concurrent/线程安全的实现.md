# 线程安全的实现

> 时间: 2020/4/8

1. 互斥同步
2. 非阻塞同步
3. 无同步方案

## 互斥同步

**同步**是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者一些，当使用信号量时）线程使用。

**互斥**是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥方式。

互斥是方法，同步是目的。

`java`最基础的互斥同步实现就是`synchronized`关键字，在执行`monitorenter`指令时，首先要去尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器增加一，而在执行`monitorexit`指令时会将锁计数器减一。一旦计数器的值为0，所就被释放了，如果获取对象锁失败了，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。

- `synchroniezd`修饰的同步块是可重入的。意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。
- 它会无条件地阻塞其他线程进入，没法强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。

除了`synchronized`关键字外，还提供了`Lock`接口来实现互斥同步手段。`ReentrantLock`是`Lock`接口的最常见的实现。多了一些高级功能:

1. 等待可中断：正在等待的线程可以选择放弃等待，改为处理其他事情。
2. 公平锁：按照申请锁的时间顺序来依次获得锁；非公平锁不保证这一点。`synchronized`是非公平的，`ReentrantLock`在默认情况下也是非公平的。一旦使用公平锁，会导致性能下降，影响吞吐量。
3. 锁绑定多个条件：一个`ReentrantLock`可以同时绑定多个`Condition`对象。`synchronized`则需要额外添加一个锁。

如何选择：

1. `synchronized`是在语法层面的同步，足够清晰，也足够简单。
2. `Lock`应该确保在`finally`释放锁，否则可能永远都不会释放持有的锁。使用`synchronized`则有虚拟机来确保即使出现异常，锁也会自动释放。
3. 性能上其实并没有相差很远（`jdk5`之后）。虚拟机更容易对`synchronzed`进行优化。

## 非阻塞同步

互斥同步面临的问题是**进行线程阻塞和唤醒所带来的性能开销**，所以也叫做阻塞同步。

需要“硬件指令集的发展”。

是一种基于冲突检测的乐观并发策略，不管风险，先进行操作，如果没有其他线程征用共享数据，那操作就直接成功了；如果共享数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施就是不断地重试，直到出现没有竞争的共享数据为止。

因为需要**要求操作和冲突检测这两个步骤具备原子性**（不可能使用互斥同步来保证），只能使用硬件。

最常用的就是`CAS`，使用`cmpxchg`指令完成。

## 无同步方案

