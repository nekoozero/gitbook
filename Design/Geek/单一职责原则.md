# 单一职责原则

SOLID 原则，由五个原则组成，分别是：**单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则**。

单一职责原则（Signle Responsibility Principle），简称 SRP，a class or module should have a single responsibility。一个类或者模块只负责完成一个职责（功能）。

> 类（class）和模块（module）的理解。
>
> 1. 模块看作比类更抽象的概念，类也可以看作模块。
> 2. 把模块看作是比类更粗粒度的代码块，模块中包含多个类，多个类组成一个模块。

不要设计大而全的类，要设计力度小、功能单一的类，如果一个类中包含了两个或两个以上业务不相干的功能放到同一个类中，那就违反了单一职责原则。

## 如何判断类的职责是否足够单一

比如下面的用户类:

```java
public class UserInfo {
  private long userId;
  private String username;
  private String email;
  private String telephone;
  private long createTime;
  private long lastLoginTime;
  private String avatarUrl;
  private String provinceOfAddress; // 省
  private String cityOfAddress; // 市
  private String regionOfAddress; // 区 
  private String detailedAddress; // 详细地址
  // ...省略其他属性和方法...
}
```

用户的地址信息是否可以作为一个单独的业务类抽出来？

**不能脱离具体的应用场景，如果系统中的这些地址字段仅仅作为展示，那么现在的用户类其实是合理的。但是如果这个系统中有电商的模块，地址信息会再物流模块中被使用，那么地址信息就可以从用户类中抽出来！**

***不同的应用场景，不同的需求背景下，对一个类的职责是否单一的判定，可能都是不一样的。***

不同的业务层面的判断也会有所不同，从“用户”的层面来看，这个类的设计是合理的，但是从“地址信息”、“登录认证信息”来看，用户类就可以继续拆分。

## 实际开发

在实际开发中，并没有必要过早的未雨绸缪，过度设计，可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候我们就可以将这个粗粒度的类，拆分成几个更细粒度的类，这就是**持续重构**。

判断职责是否单一的依据是非常主观的，实际上一些侧面的判断指标更具有指导意义和可执行性：

- 类的代码行数、函数或者属性过多
- 类依赖的其他类过多，或者依赖类的其他类过多
- 私有方法过多
- 类的名字难以命名
- 类中大量的方法都是集中操作类的某几个属性

## 是否越单一越好

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类的职责越单一，类依赖的被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高类聚、低耦合。但是如果拆分的过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。



> 内聚和耦合是一对意思，从相反的方向进行阐述
>
> 1. 内聚是从功能相关来谈，主张高内聚。把功能高度相关的内容不必要地分离开，就降低了内聚性，成了低内聚。
> 2. 耦合是从功能无关来谈，主张低耦合。把功能明显无关的内容随意结合起来，就增加了耦合性，成了高耦合。