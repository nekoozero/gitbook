---
title: 单例模式
date: 2019-09-14 11:34:30
category: java编程 
---

## 概念

其属于创建型模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。



单例模式一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类对象。

* 优点

  在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）。

  避免对资源的多重占用（比如写文件操作）。

## 实现方式

如果一个类对外提供了public的狗杂方法，那么外界就可以任意创建该类的对象。所以，要想限制对象的产生，一个办法就是将构造函数变为私有的（至少是受保护的），使外面的类不能通过引用来产生对象。同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。

### 饿汉式

简单的单例实现

```java
public class Singleton {
    //创建一个Singleton对象
    private static Sileton instance = new Singleton();
    //将构造方法设为私有的
    private Singleton() {
        
    }
    //向外提供获取这个对象的方法
    public static Singleton getInstance() {
        return instance;
    }
}
```

通过static的静态初始化方式，在该类第一次被加载的时候，就有一个Singleton的实例被创建出来了，这样就保证在第一次使用该对象的时候后，他已经被初始化好了。

由于该**实例在类被加载的**时候就创建出来了，所以也避免了线程安全问题

> 饿汉式单例，在类被加载的时候就会实例化。这也许会造成不必要的消耗，因为可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。解决方法：静态内部类的形式、懒汉式。

#### 静态内部类

```java

/**
 * 静态内部类/类初始化
   该方式不会出现线程安全的问题，即使发生重排序，其他线程也是无法看到的
 */
public class StaticInnerClassSingleton {
    //在静态内部类中初始化实例对象
    private static class SingletonHolder {
        private static final  StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();
    }
    //私有的构造方法
    private StaticInnerClassSingleton() {
        
    }
    //对外提供获取实例的静态方法
    public static StaticInnerClassSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

同样利用classloder的机制来保证初始化instance时只有一个线程。

差别：饿汉式只要类被装载了，那么instance就会被实例化（没有达到lazy loading的效果）。而内部静态类的方法，在StaticInnerClassSingleton被加载的时候，INSTANCE不一定会被初始化，因为SingletonHolder没有被主动使用，因为只有显式通过调用getInstance方法时，才会显式装载SingletonHolder类，从而实例化INSTANCE。

### 懒汉式

在该对象真正被使用的时候才会实例化的单例模式---懒汉模式。

```java
public class LazySingleton {
    //声明变量
    private static LazySingleton lazySingleton;
    //私有的构造方法
    private LazySingleton() {
        
    }
    //对外提供获取对象的方法
    public static LazySingleton getInstance() {
        if (lazySingleton == null) {
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }
    
}
```

懒汉式是不会提前将对象初始化出来，只有当调用getInstance方法的时候才会去初始化对象，如果已经初始化过了，那么就返回初始化好的对象。

但是，上面的代码有一个致命的问题：

存在线程安全问题，在多线程的情况下，如果两个或者两个以上线程同时进入if语句中，并且对象也没有被初始化，那么么这些线程就会去new一个对象（这些对象都不是同一个对象）出来。

### 线程安全的懒汉式

给创建对象的步骤加锁

```java
public class SynchronizeLazySingleton {
    //声明变量
    private static SynchronizeLazySingleton synchronizeLazySingleton;
    //私有的构造方法
    private SynchronizeLazySingleton() {

    }
    //对外提供获取对象的方法 对该方法加锁
    public static synchronized SynchronizeLazySingleton getInstance() {
        if (synchronizeLazySingleton == null) {
            synchronizeLazySingleton = new SynchronizeLazySingleton();
        }
        return synchronizeLazySingleton;
    }
}
```

其实就是加了一个synchronized关键字，很简单，但是上面的效率很低，因为99%的情况下是不需要做同步处理的。上面的写法时该方法执行都需要同步，但是其实只有第一次创建的情况下才需要同步，其他的情况都是直接return synchronizeLazySingleton就可以了，是不需要做同步的。

### 双重校验锁

锁的范围既然太大了，只要缩小锁的范围就可以了:

```java
public class SynchronizeLazySingletonAdvance {
    //声明变量
    private static SynchronizeLazySingletonAdvance synchronizeLazySingleton;
    //私有的构造方法
    private SynchronizeLazySingletonAdvance() {

    }
    //对外提供获取对象的方法
    public static  SynchronizeLazySingletonAdvance getInstance() {
        if(synchronizeLazySingleton == null) {    // problem
            synchronized (SynchronizeLazySingletonAdvance.class) {
                if (synchronizeLazySingleton == null) {
                    synchronizeLazySingleton = new SynchronizeLazySingletonAdvance();
                }
            }
        }
        return synchronizeLazySingleton;
    }
}
```

这样不是新建对象的线程就不需要走synchronized块了，与上面相比，双重校验就是用来缩小synchronized块的。再准确点说就是，第一个判断是判断线程是否要走synchroniezd快，第二个判断就是判断走synchronized块的线程是否需要去创建对象。

这样看来，实现了惰性初始化，解决了同步问题，还减小了锁的范围，提高了效率。但还是存在隐患，主要和JMM有关。

假设A线程进入synchronized块对对象进行初始化，由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化**之前**，更新变量并将其指向**部分初始化的对象**。

线程B发现共享变量已经被初始化并返回变量，但此时变量仍没有被完全初始化。在A完成初始化之前共享变量对B可见，引起这个问题。

* 问题的根源

  instance = new Singleton();创建一个对象，分解为如下三步代码：

  ```java
  memory = allocate();   //1.分配对象的内存空间
  ctorInstance(memory);  //2.初始化对象
  instance = memory;     //3.设置instance指向刚分配的内存地址
  ```

  在2和3中，可能会被重排序（在JIT编译器上，这种重排序是真实发生的）。

  ```java
  memory = allocate();   //1.分配对象的内存空间
  instance = memory;     //3.设置instance指向刚分配的内存地址
                         //此时对象还没有被初始化
  ctorInstance(memory);  //2.初始化对象
  ```

  不正确的实现双重检查锁导致异常结果可能会间歇性出现，重现异常是十分困难的。

### 使用volatile

```java
/**
 * volatile
 */
public class VolatileSingleton implements Serilizable{
    //声明变量
    private static volatile VolatileSingleton synchronizeLazySingleton;
    //私有的构造方法
    private VolatileSingleton() {

    }
    //对外提供获取对象的方法
    public static VolatileSingleton getInstance() {
        if(synchronizeLazySingleton == null) {
            synchronized (VolatileSingleton.class) {
                if (synchronizeLazySingleton == null) {
                    synchronizeLazySingleton = new VolatileSingleton();
                }
            }
        }
        return synchronizeLazySingleton;
    }
    
    //该方法可以防止序列化对单例的破坏
    private Object readResolve() {
        return synchronizeLazySingleton;
    }
}
```

这个解决了刚才提到的问题，**volatile关键字禁止重排序**（volatile还有其他作用，这边不详说）。

这种方式遇到序列化的时候也可能存在问题。readResolve()方法可以帮忙解决。

### 使用final

```java
class FinalWrapper<T> {
    public final T value;
    public FinalWrapper(T value) {
        this.value = value;
    }
}
public class FinalSingleton {
    private FinalWrapper<FinalSingleton> helperWrapper = null;
    public FinalSingleton getInstance() {
        FinalWrapper<FinalSingleton> wrapper = helperWrapper;
        if(wrapper==null) {
            synchronized (this) {
                if(helperWrapper == null) {
                    helperWrapper = new FinalWrapper<FinalSingleton>(new FinalSingleton());
                }
                wrapper = helperWrapper;
            }
        }
        return wrapper.value;
    }
}
```

### 枚举

```java
public enum Singleton {
    INSTANCE;
    Singleton() {}
}
```

枚举避免多线程的问题，防止反序列化重新创建对象

