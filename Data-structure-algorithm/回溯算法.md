# 回溯算法

解决一个回溯问题，实际上就是一个决策树的遍历过程。

1. 路径：已经做出的选择
2. 选择列表：当前可以做的选择
3. 结束条件：到达决策树地测嗯，无法在做出选择的条件

**其核心就是 for 循环里面的递归，在递归调用前“做选择”，在递归调用之后“撤销选择”。**

代码框架：

```java
result = []
void backtrack(路径, 选择列表) {
    if(满足结束条件){
        result.add(路径)
        return;
    }

    for (选择 in 选择列表){
        做选择
        backtrack(路径, 选择列表);// 回溯
        撤销选择
    }
}
```



## 全排列

比如给出三个数字[1,2,3]（不包含重复数字），一般会如下的方式排列：

![全排列](https://img-blog.csdnimg.cn/20200702134757690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FBUTEyMzY2Ng==,size_16,color_FFFFFF,t_70)

这棵树就是回溯方法的“决策树”。将上述三个点翻译过来就是：

**[2] 就是路劲，已经选择过的节点，[1,3] 就是选择列表，而结束条件就是选择列表为空的时候了。**

![](https://img-blog.csdnimg.cn/20200702135341483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FBUTEyMzY2Ng==,size_16,color_FFFFFF,t_70)

定义的 backtrack 函数其实就像是一个指针，在这颗树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。

多叉树的遍历框架：

```java
void traverse(TreeNode root) {
    for (TreeNode child : root.childern) {
        // 前序遍历需要的操作
        traverse(child);
        // 后序遍历需要的操作
    }
}
```

![多叉树遍历](https://img-blog.csdnimg.cn/20200702135758233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FBUTEyMzY2Ng==,size_16,color_FFFFFF,t_70)

**前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。**

![](https://img-blog.csdnimg.cn/20200702135824932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FBUTEyMzY2Ng==,size_16,color_FFFFFF,t_70)

再看核心代码：

```java
for (选择 in 选择列表){
    // 做选择。相当于前序遍历的操作
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    // 撤销选择。相当于后序遍历的操作
    路径.remove(选择)
    将该选择再加入选择列表
}
```

只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。

全排列代码：

```java
List<List<Integer>> res = new LinkedList<>();

/* 主函数，输入一组不重复的数字，返回它们的全排列 */
List<List<Integer>> permute(int[] nums) {
    // 记录「路径」
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, track);
    return res;
}

// 路径：记录在 track 中
// 选择列表：nums 中不存在于 track 的那些元素
// 结束条件：nums 中的元素全都在 track 中出现
void backtrack(int[] nums, LinkedList<Integer> track) {
    // 触发结束条件
    if (track.size() == nums.length) {
        res.add(new LinkedList(track));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        // 排除不合法的选择
        if (track.contains(nums[i]))
            continue;
        // 做选择
        track.add(nums[i]);
        // 进入下一层决策树
        backtrack(nums, track);
        // 取消选择
        track.removeLast();
    }
}
```

这个算法解决全排列不是很高效，因为对链表使用 contains 方法需要 O(N)  的时间复杂度。有更好的方法通过元素交换达到目的。

不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整颗决策树是无法避免的。**这也是回溯算法的一个特点，不想动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。**

















