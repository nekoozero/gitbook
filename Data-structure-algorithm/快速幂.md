快速运算底数的n次幂。其时间复杂度为O(log2N)，与朴素的O(N)相比效率有了极大的提高。

## 核心思想

每一步都把指数分成两半，而对应的底数做平方运算，这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而且最后表示的结果却一直不会变。

## 题目

> 求A^B的最后三位表示的整数。

**求最后的几位整数，我们做取模运算就可以了，比如最后三位，我们可以把该数字和1000取模，最后一位，可以和10取模**

如果这题，我们使用简单for循环把结果算出来然后和1000取模的话，不做特殊处理的话，要么时间复杂度很高，要么就是得不到正确结果，比如返回0.

```java
    public static long normalPow1(long base, long power) {
        long result = 1;
        for (int i = 0; i < power; i++) {
            result = result * base;
        }
        return result % 1000;
    }
```

返回结果：

![image.png](http://www.qxnekoo.cn:8888/images/2022/01/05/image.png)

根据取模运算的方程：__**(a * b) % p = (a % p * b % p) % p **__

我们可以对代码进行优化：

```java
    public static long normalPow2(long base, long power) {
        long result = 1;
        for (int i = 0; i < power; i++) {
            result = result * base;
            result = result % 1000;
        }
        return result % 1000;
    }

```

![image-1.png](http://www.qxnekoo.cn:8888/images/2022/01/05/image-1.png)

虽然最后计算出了结果，**但是时间复杂度的话，很明显就是O(N)。**

快速幂的应用场景就有了。

> 3^10=3*3*3*3*3*3*3*3*3*3
>
> //尽量想办法把指数变小来，这里的指数为10
>
> 3^10=(3*3)*(3*3)*(3*3)*(3*3)*(3*3)*
>
> *3^10=(3*3)^5
>
> 3^10=9^5
>
> //此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10原本需要执行10次循环操作，求9^5却只需要执行5次循环操作，但是3^10却等于9^5,我们用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000=4^5000,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。
>
> //现在我们的问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行5/2，然而，这里还有另一种方法能表示9^5
>
> 9^5=（9^4）*（9^1）
>
> //此时我们抽出了一个底数的一次方，这里即为9^1，这个9^1我们先单独移出来,剩下的9^4又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作
>
> 9^5=（81^2）*(9^1)
>
> //把指数缩小一半，底数执行平方操作
>
> 9^5=（6561^1）*(9^1)*
>
> *9^5=（6561^0）*(9^1)*(6561^1)=1*(9^1)*(6561^1)=(9^1)*(6561^1)=9*6561=59049

代码实现：

```java
public static long normalPow3(long base, long power) {
        long result = 1;
        while (power > 0) {
            if (power % 2 == 0) {
                //如果指数为偶数
                //把指数缩小为一半
                power = power / 2;
                //底数变大成原来的平方
                base = base * base % 1000;
            } else {
                //如果指数为奇数
                //把指数减去1，使其变成一个偶数
                power = power - 1;
                //此时记得要把指数为奇数时分离出来的底数的一次方收集好
                result = result * base % 1000;
                //此时指数为偶数，可以继续执行操作
                power = power / 2;
                base = base * base % 1000;
            }
        }
        return result;
    }

```

![image-2.png](http://www.qxnekoo.cn:8888/images/2022/01/05/image-2.png)

代码可以接着进行优化：

```java
public static long normalPow4(long base, long power) {
    long result = 1;
    while (power > 0) {
        if (power % 2 == 1) {
            result = result * base % 1000;
        }
        power = power / 2;
        base = base * base % 1000;
    }
    return result;
}
```

