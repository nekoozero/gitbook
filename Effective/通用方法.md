# 第二章：对于所有对象都通用的方法

> 时间： 2020/8/10

## 10.重写 equals 方法时遵守通用约定

什么时候需要重写 equals 方法呢？

如果一个类包含一个逻辑相等的概念，此概念有别于对象标识，而且父类还没有重写过 equals 方法。这通常用在值类的情况。

> 值类只是一个表示值的类，例如 Integer 或 String 类。程序员使用 equals 方法比较值对象的引用，期望它们在逻辑上是否相等，而不是引用相同的对象。不仅如此，还支持重写过 equals 的实例作为 Map 的键(key) ，或者 Set 里的元素，已满足预期和期望的行为。

通用约定：equals 方法实现了一个等价关系，它有以下属性：

- 自反性：对于任何非空引用 x，x.equals(x) 必须返回 true。
- 对称性：对于任何非空引用 x 和 y，如果且当且仅当 y.equals(x) 返回true时 x.equals(y) 必须返回true。
- 传递性：对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true。
- 一致性：对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false。
- 对于任何非空引用 x，x.equals(null) 必须返回 false。

最重要的提醒：

1. 当重写 equals 方法时，同时也要重写 hashCode 方法。

2. 不要让 equals 方法试图太聪明。例如，File 类不应该试图将引用的符号连接等同于同一文件对象。

3. 在 equals 时方法声明中，不要将参数 Object 替换成其他类型。换了的话就不是重写，而是重载了。

   ```java
   //错误示范
   @Override
   public boolean equals(MyClass o) {
   }
   ```

总之，除非必须，在很多情况下，不要重写 equals 方法，从 Object 继承的实现完全可能就是想要的。如果确实重写了 equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面 equals 约定里五个规定的方式去比较。

## 11.覆盖 equals 时总要覆盖 hashCode

在每个覆盖 equals 方法的类中，都必须覆盖 hashCode 方法。

因没有覆盖 hashCode 而违反的关键约定是第二条：相等的对象必须具有相等的散列码（hash code）。 

## 12.始终重写 toString 方法

toString 的通用约定要求，返回的字符串应该是一个简单但内容丰富的表示，对人们来说是很容易阅读的。（建议所有的子类重写这个方法）

当对象传递到 println、printf、字符串连接操作符或断言，或者由调试器打印时，toString 方法会自动被调用。

实际上，toString 方法应该返回对象中包含的所有需要关注的信息，如果对象很大或者包含不利于字符串表示的状态，这是不切实际的。这种情况下，toString 应该返回一个摘要。

除非父类已经这样做了，否则在每个实例化的类中从写 Object 的 toString 实现，它使得类更加舒适地使用和协助调试。toString 方法应该以一种美观的格式返回对象的简明有用的描述。

## 13.谨慎地重写 clone 方法

Cloneable 接口的目的是作为一个 mixin 接口。它主要的缺点是缺少 clone 方法，但他决定了 Object 受保护的 clone 方法实现的行为：如果一个类实现了 Cloneable 接口，那么 Object 的 clone 方法将返回该对象的逐个属性（field-by-field）拷贝；否则会抛出 CloneNotSupportedException 异常。这是一个反常的接口使用，不应该仿效。

**通常，实现一个接口用来表示可以为客户做什么，但是，Cloneable 接口会修改父类上受保护方法（Object 的 clone 方法是受保护的）的行为。**

如果一个 final 类有一个不调用 super.clone 的 clone 方法，那么这个类没有理由实现 Cloneable 接口，因为它不依赖于 Object 的 clone 实现的行为。

假如希望在一个类中实现 Cloneable 接口，它的父类提供一个行为良好的 clone 方法。

考虑到与 Cloneable 接口相关的所有问题，新的接口不应该继承他，新的可扩展类不应该实现它。虽然实现 Cloneable 接口对 final 类没有危害，但应该将其视为性能优化的角度，仅在极少数情况下才是合理的。

通常，复制功能最好由构造方法或工厂提供，一个明显的例外是数组，它最好用 clone 方法复制。

## 14.考虑实现 Comparable 接口

compareTo 方法并没有在 Object 类中声明，它是 Comparable 中的唯一方法。通过实现 Comparable 接口，一个类表明它的实例有一个自然顺序。

实现 Comparable 接口，可以让类与所有依赖此接口的通用算法和集合实现进行互操作，几乎 Java 平台所有平台类库中的所有值类以及所有枚举类型都实现了 Comparable 接口。编写具有明显自然顺序（字母顺序，数字顺序或时间顺序）的值类，则应该实现 Comparable 接口。

考虑到 BigDecimal 类，其 compareTo 方法与 equals 不一致，如果创建一个空的 HashSet 实例，然后添加 new BigDecimal("1.0") 和 new BigDecimal("1.00")，则该集合将包含两个元素，因为与 equals 方法进行比较时，添加到集合的两个 BigDecimal 实例是不相等的。但是如果使用 TreeSet，则集合只包含一个元素，因为使用 compareTo 方法进行比较时，两个 BigDecimal 实例是相等的。

在 Java 8 中 Comparator 接口提供了一系列比较器方法，可以使比较器流畅地构建。 这些比较器可以用来实 现 compareTo 方法，就像 Comparable 接口所要求的那样。 在使用这种方法时，考虑使用 Java 的静态导入，以便可以通过其简单名称来引用比较器静态方法，以使其清晰简洁。 

```java
private static final Comparator<User> COMPARATOR = Comparator.comparingInt((User u)->u.age);

@Override
public int compareTo(User o) {
    return COMPARATOR.compare(this,o);
}
```

总而言之，无论何时实现具有合理排序的值类，你都应该让该类实现 Comparable 接口，以便在基于比较的集合中轻松对其实例进行排序，搜索和使用。 比较 compareTo 方法的实现中的字段值时，请避免使用"<"和">"运算 符。 相反，使用包装类中的静态 compare 方法或 Comparator 接口中的构建方法。

## 15.使类和成员的可访问性最小化

将设计良好的组件与设计不佳的组件区分开来的最重要的因素是，组件将其内部数据和其他组件的其他实现细节隐藏起来。一个设计良好的组件隐藏了它的所有实现细节，干净地将它的 API 与它的实现分离开来。然后组件只通过他们的 API 进行通信，并且对彼此内部的工作一无所知。这称为信息隐藏或封装，是软件设计的基本原则。

对于顶层（非嵌套的）类和接口，只有两个可能的访问级别：包级私有和公共的。

**通过将其设置为包级私有，可以将其作为实现的一部分，而不是导出的 API**，可以修改、替换、或者在后续的版本中消除它，而不必担心损害现有的客户端。如果把它公开，就有义务永远地支持它，以保持兼容性。

如果一个包级私有顶级类或接口只被一个类使用，那么可以考虑这个类作为使用它的唯一类的私有静态嵌套类。这将它的可访问性从包级的所有类减少到使用它的一个类。但是，减少不必要的公共类的可访问性要比包级私有的顶级类更重要：公共类是包的 API 的一部分，而包级私有的顶级类已经是这个包实现的一部分了。

对于成员（属性、方法、嵌套类和嵌套接口），有四种可能访问级别：

- private：该成员只能在声明它的顶级类内访问。
- package-private：成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符（接口成员除外，它默认是公共的），这是默认访问级别。
- protected：成员可以从被声明的类的子类中访问，以及它声明的包中的任何类。
- public：该成员可以从任何地方被访问。

在仔细设计你的类的公共 API 之后，你的反应应该是让所有其他成员设计为私有的。 只有当同一个包中的其他类真的需要访问成员时，需要删除私有修饰符，从而使成员包成为包级私有的。也就是说，私有成员和包级私有成员都是类 实现的一部分，通常不会影响其导出的 API。

对于公共类的成员，当访问级别从包私有到受保护级时，可访问性会大大增加。受保护的成员是类导出的 API 的一部分，并且必须永远支持。此外，导出类的受保护成员表示对实现细节的公开承诺。对受保护成员的需求应该相对较少。

总而言之，应该尽可能地减少程序元素的可访问性（在合理访问内）。在仔细设计一个最小化的公共 API 之后，应该防止任何散乱的类，接口或成员称为 API 的一部分。除了作为常量的公共静态属性 final 属性外，公共类不应该有公共属性。确保 public static final 属性引用的对象是不可变的。











