# 第二章：对于所有对象都通用的方法

> 时间： 2020/8/10

## 10.重写 equals 方法时遵守通用约定

什么时候需要重写 equals 方法呢？

如果一个类包含一个逻辑相等的概念，此概念有别于对象标识，而且父类还没有重写过 equals 方法。这通常用在值类的情况。

> 值类只是一个表示值的类，例如 Integer 或 String 类。程序员使用 equals 方法比较值对象的引用，期望它们在逻辑上是否相等，而不是引用相同的对象。不仅如此，还支持重写过 equals 的实例作为 Map 的键(key) ，或者 Set 里的元素，已满足预期和期望的行为。

通用约定：equals 方法实现了一个等价关系，它有以下属性：

- 自反性：对于任何非空引用 x，x.equals(x) 必须返回 true。
- 对称性：对于任何非空引用 x 和 y，如果且当且仅当 y.equals(x) 返回true时 x.equals(y) 必须返回true。
- 传递性：对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true。
- 一致性：对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false。
- 对于任何非空引用 x，x.equals(null) 必须返回 false。

最重要的提醒：

1. 当重写 equals 方法时，同时也要重写 hashCode 方法。

2. 不要让 equals 方法试图太聪明。例如，File 类不应该试图将引用的符号连接等同于同一文件对象。

3. 在 equals 时方法声明中，不要将参数 Object 替换成其他类型。换了的话就不是重写，而是重载了。

   ```java
   //错误示范
   @Override
   public boolean equals(MyClass o) {
   }
   ```

总之，除非必须，在很多情况下，不要重写 equals 方法，从 Object 继承的实现完全可能就是想要的。如果确实重写了 equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面 equals 约定里五个规定的方式去比较。

## 11.覆盖 equals 时总要覆盖 hashCode

在每个覆盖 equals 方法的类中，都必须覆盖 hashCode 方法。

因没有覆盖 hashCode 而违反的关键约定是第二条：相等的对象必须具有相等的散列码（hash code）。 

## 12.始终重写 toString 方法

toString 的通用约定要求，返回的字符串应该是一个简单但内容丰富的表示，对人们来说是很容易阅读的。（建议所有的子类重写这个方法）

当对象传递到 println、printf、字符串连接操作符或断言，或者由调试器打印时，toString 方法会自动被调用。

实际上，toString 方法应该返回对象中包含的所有需要关注的信息，如果对象很大或者包含不利于字符串表示的状态，这是不切实际的。这种情况下，toString 应该返回一个摘要。

除非父类已经这样做了，否则在每个实例化的类中从写 Object 的 toString 实现，它使得类更加舒适地使用和协助调试。toString 方法应该以一种美观的格式返回对象的简明有用的描述。















