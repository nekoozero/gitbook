# synchronized

> 时间: 2020/4/8

众所周知 `synchronized` 关键字是解决并发问题常用解决方案，属于互斥同步，有以下三种使用方式:

- 同步普通方法，锁的是当前对象。
- 同步静态方法，锁的是当前 `Class` 对象。
- 同步块，锁的是 `()` 中的对象。

实现原理：
`JVM` 是通过进入、退出对象监视器( `Monitor` )来实现对同步块的同步的。

具体实现是在编译之后在同步方法调用前加入一个 `monitor.enter` 指令，在退出方法和异常处插入 `monitor.exit` 的指令。

其本质就是对一个对象监视器( `Monitor` )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。

而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 `monitor.exit` 之后才能尝试继续获取锁。

> 编译器需要确保方法中调用过的每条`monitorenter`指令都要执行对应的`monitorexit` 指令。为了保证在方法异常时，`monitorenter`和`monitorexit`指令也能正常配对执行，编译器会自动产生一个异常处理器，它的目的就是用来执行 异常的`monitorexit`指令。而字节码中多出的`monitorexit`指令，就是异常结束时，被执行用来释放`monitor`的。

对于方法，则是使用的是`ACC_SYNCHRONIZED`标识，`JVM`通过`ACC_SYNCHRONIZED`标识，就可以知道这是一个需要同步的方法，进而执行同步的过程。**执行线程将先获取monitor**，获取成功之后才能执行方法体，**方法执行完后再释放monitor**。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。

## Monitor对象(需要去了解对象头)

synchronized的对象锁，其指针指向的是一个monitor对象（由C++实现）的起始地址。每个对象实例都会有一个 monitor。其中monitor可以与对象一起创建、销毁；亦或者当线程试图获取对象锁时自动生成。

![monitor.png](http://www.qxnekoo.cn:8888/images/2020/03/20/monitor.png)

- `Owner`：初始时为NULL表示当前没有任何线程拥有该`monitor`，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；
- `EntryQ`：关联一个系统互斥锁（`semaphore`），阻塞所有试图锁住`monitor`失败的线程。
- `RcThis`：表示`blocked`或`waiting`在该`monitor`上的所有线程的个数。
- `Nest`：用来实现重入锁的计数。
- `HashCode`：保存从对象头拷贝过来的`HashCode`值（可能还包含`GC age`）。
- `Candidate`：用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。`Candidate`只有两种可能的值：0表示没有需要唤醒的线程，1表示要唤醒一个继任线程来竞争锁。

那么monitor的作用是什么呢？**在 `java` 虚拟机中，线程一旦进入到被`synchronized`修饰的方法或代码块时，指定的锁对象通过某些操作将对象头中的`LockWord`指向`monitor`的起始地址与之关联，同时`monitor`中的`Owner`存放拥有该锁的线程的唯一标识，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码。**

Monitor对象结构：

![Monitor.png](http://www.qxnekoo.cn:8888/images/2020/04/25/Monitor.png)

ObjectMonitor:

```c++
ObjectMonitor() {
    _header       = NULL;//markOop对象头
    _count        = 0;
    _waiters      = 0,//等待线程数
    _recursions   = 0;//重入次数
    _object       = NULL;//监视器锁寄生的对象。锁不是平白出现的，而是寄托存储于对象中。
    _owner        = NULL;//指向获得ObjectMonitor对象的线程或基础锁
    _WaitSet      = NULL;//处于wait状态的线程，会被加入到wait set；
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ;//处于等待锁block状态的线程，会被加入到entry set；
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;// _owner is (Thread *) vs SP/BasicLock
    _previous_owner_tid = 0;// 监视器前一个拥有者线程的ID
}
```



![ObjectMonitor.png](http://www.qxnekoo.cn:8888/images/2020/04/25/ObjectMonitor.png)

这部分的内容、原理确实比较复杂，贴上大佬的文章：

https://www.cnblogs.com/dennyzhangdd/p/6734638.html#_label2

https://mp.weixin.qq.com/s/KFgAY3g4tfuaKumVswID4A

md，把我给看跪了！！！！

## 锁的升级

### 偏向锁

为了进一步的降低获取锁的代价，`JDK1.6` 之后还引入了偏向锁。

偏向锁的特征是:**锁不存在多线程竞争，并且应由一个线程多次获得锁，为了让线程获得锁的代价更低而引入了偏向锁**。

当线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录存储偏向的线程`ID`，，以后该线程进入和退出同步块并获取锁时就不需要进行`CAS`操作来加锁和解锁了，只需要简单地测试一下对象头的`Mark Word`里是否存贮这执行当前线程的偏向锁。如果测试成功，表示线程已经获取到了锁。如果测试失败，则需要测试一下`Mark Word`中偏向锁的表示是否设置为1（表示当前是偏向锁）；如果没有设置，则使用`CAS`竞争锁，如果设置了，则尝试使用`CAS`将对象头的偏向锁指向当前线程。

#### 释放锁

当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 `Mark Word` 设置为无锁或者是轻量锁状态。

偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 `-XX:-userBiasedLocking=false` 来关闭偏向锁，并默认进入轻量锁。

### 轻量锁

当代码进入同步块之前，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(`Lock Record`)区域，同时将锁对象的对象头中 `Mark Word` 拷贝到锁记录中，再尝试使用 `CAS` 将 `Mark Word` 更新为指向锁记录的指针。

如果更新**成功**，当前线程就获得了锁。

如果更新**失败** `JVM` 会先检查锁对象的 `Mark Word` 是否指向当前线程的锁记录。

如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。

不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，**轻量锁就会膨胀为重量锁**。

#### 解锁

轻量锁的解锁过程也是利用 `CAS` 来实现的，会尝试锁记录替换回锁对象的 `Mark Word` 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为`重量锁`)

轻量锁能提升性能的原因是：

认为大多数锁在整个同步周期都不存在竞争，所以使用 `CAS` 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 `CAS` 的开销，甚至比重量锁更慢。

### 优缺点

|    锁    |                             优点                             |                      缺点                      |              适用场景              |
| :------: | :----------------------------------------------------------: | :--------------------------------------------: | :--------------------------------: |
|  偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景 |
| 轻量级锁 |           竞争的线程不会阻塞，提高了程序的响应速度           | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间；同步块执行速度非常快 |
| 重量级锁 |               线程竞争不使用自旋，不会消耗CPU                |             线程阻塞，响应时间缓慢             |   追求吞吐量；同步块执行速度较长   |

偏向锁比轻量锁更容易被终结，轻量锁是在有锁竞争出现时升级为重量锁，而一般偏向锁是在有不同线程申请锁时升级为轻量锁，这也就意味着假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，**这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量锁，如果是线程1持有锁，且2也要争夺偏向锁，则直接到轻量级锁状态**



一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用`CAS`操作，并将对象头中的`ThreadID`改成自己的`ID`，之后再次访问这个对象时，只需要对比`ID`，不需要再使用`CAS`在进行操作。

一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象是偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（**偏向锁就是这个时候升级为轻量级锁的**）。**假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量锁，如果是线程1持有锁，且2也要争夺偏向锁，则直接到轻量级锁状态**

轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是**当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止`CPU`空转。**

### 其他优化

#### 自旋

互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态完成，这些操作给系统的并发性能带来了很大的压力。

如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，我们只需让线程执行一个忙循环（自旋）。

#### 优缺点

自旋等待不能代替阻塞，且不说对处理器数量的要求，自选等待本身虽然避免了线程切换的开销，但他是要占用处理器时间的，因此，如果所被占用的时间很少，自旋等待的效果就会很好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白的消耗处理器资源了，而不会做任何有用的工作，反而会带来性能上的浪费。

#### 自适应自旋

在使用 `CAS` 时，如果操作失败，`CAS` 会自旋再次尝试。由于自旋是需要消耗 `CPU` 资源的，所以如果长期自旋就白白浪费了 `CPU`。`JDK1.6`加入了适应性自旋:

> 如果某个锁自旋很少成功获得，那么下一次就会减少自旋。

如果自同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而他将允许自旋等待持续相对更长的时间，比如100个循环。

如果对于某个锁，自旋很少成功过，那在以后要获取这个所示将可能省略掉自旋过程，以避免浪费处理器时间。

