# 锁优化

> 时间: 2020/4/6

## 自旋锁与自适应锁

**互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态去完成。**

如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时执行，就可以让后面请求锁的线程稍等一会儿，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋等待本身虽然避免了线程切换的开销，但它姚占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，但是如果时间比较长，自旋只会白白消耗处理器资源，而不会做任何有价值的工作，会带来性能的浪费。所以，如果自旋尝试一定次数后还是没有获得锁，就会以传统的方式挂起线程。

`jdk6`中引入了适应性锁。意味着自旋的时间不是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。

> 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能成功，进而允许自旋等待持续相对更长的时间。
>
> 另一方面，如果对于某个锁，自旋很少成功获得过锁，在那以后要获取这个锁时将很有可能直接省略掉自旋过程，以避免浪费处理器资源。

## 锁消除

是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无需在进行。

## 锁粗化

编写代码时推荐将同步块的作用范围限制尽量小，这样是为了使得需要同步的操作数量尽可能变少，等待锁的线程也尽可能快地拿到锁。

大部分情况下是正确的。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步也会导致不必要的性能损耗。