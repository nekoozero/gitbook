# HashMap扩容时是否hash

> 2020/4/29

看面试题遇到的一个问题，扩容是是否会重新 `hash()`?

第一反应是 `jdk7` 会，`jdk8` 不会，因为印象中大学的时候研究过一次，还去找了当时的记录：

![college_hashMap.png](http://www.qxnekoo.cn:8888/images/2020/04/29/college_hashMap.png)

这里再次研究下具体原理吧!先看一些运算符，每次看到这些运算符都不记得它们的作用，尴尬!

A = 0011 1100 => 60

B = 0000 1101 => 13



-------

| 操作符              | 描述                                                         | 例子                         |
| ------------------- | ------------------------------------------------------------ | :--------------------------- |
| & 按位与运算符      | 如果相对应位都是1，则结果为1，否则为0                        | （A&B），得到12，即0000 110  |
| &#x7C; 按位或运算符 | 如果相对应位都是0，则结果为0，否则为1                        | （AlB），得到61，即0011 1101 |
| ^ 异或运算符        | 如果相对应位值相同，则结果为0，否则为1                       | （A^B），得到49，即0011 0001 |
| ~ 取反运算符        | 按位取反运算符，翻转操作数的每一位，即0变成1,1变成0          | （~A）得到-61，即11100 0011  |
| <<                  | 按位左移运算符。左操作数按位左移右操作数指定的位数                  A<<n 相等于A乘以2的n次幂。 | A<<2得到240，即1111 0000     |
| >>                  | 按位右移运算符。左操作数按位右移右操作数指定的位数                      A>>n相等于A除以2的n次幂 | A>>2得到15，即1111           |
| >>>                 | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 | A>>>2得到15即0000 1111       |



首先找到计算哈希桶位置代码，也不难找，具体如下（jdk8）:

![hash.png](http://www.qxnekoo.cn:8888/images/2020/04/29/hash.png)

这个是具体的 `hash()` 方法，还是很好找的，不过计算哈希桶位置的代码在 `jdk8` 中变了，但是 `put()` 方法中肯定会调用的，接着往下找就好了，

![compute_buket.png](http://www.qxnekoo.cn:8888/images/2020/04/29/compute_buket.png)

计算数组的位置，其实也就是哈希桶的位置了。下面针对这两个方法研究：

```java
int h = "nekooaa".hashCode();
System.out.println(Integer.toBinaryString(h)+" hashCode值 h");
//h>>>16   这里前面加上16个零，主要是为了对齐，方便我们肉眼观察
System.out.println("0000000000000000"+Integer.toBinaryString(h >>> 16)+" h>>>16");
int x = h ^ (h >>> 16);
//h ^ h >>> 16
System.out.println(Integer.toBinaryString(x)+" h ^ h >>> 16 这个值会赋给hash");
// length-1 & hash  supplement函数的作用也是为了对齐
System.out.println(supplement(Integer.toBinaryString(15)) +" length-1");
System.out.println((x & 15) + " length-1 & hash");
```

代码其实很简单，挑一个字符串的字符串，`HashMap` 的哈希桶个数我就使用默认的 16 来测试，通过计算来得到这个字符串如果放到 `HashMap` 中的具体位置。运行一下看看结果：

![result_hash.png](http://www.qxnekoo.cn:8888/images/2020/04/29/result_hash.png)

也就是说，16 个哈希桶，使用这个字符串，将会放到第 10 个 `hash` 桶。

那我们再算算如果是 32 个哈希桶（也就是扩容到 32）的话，这个位置会是几呢？

其实想一想，不管是多少个哈希桶，这个字符串的 `hashCode` 值是不会变得，所以一直到 `h ^ h >>> 16` 这步，运算结果都是不会变得，**唯一变得是 `length-1`**，会怎样变呢？改一下数据，15 改成 31，运行一下：

![result_hash2.png](http://www.qxnekoo.cn:8888/images/2020/04/29/result_hash2.png)

<u>2 的 n 次幂减去 1 得到的二进制，有效位一定都是 1，在进行与运算（&）时就会有奇效了，而且在这种扩容是原来容量 2 倍的情况下，这边的 `length-1` 得到的二进制数会比扩容之前的 `length-1` 左边多一个 1 出来</u>，(比如上面，15 的时候二进制数为 1111，31 的时候就是 11111),所以在与 `h ^ h >>> 16`计算的时候只要关注多出来的那个 1 对应 `h ^ h >>> 16`的数字是 0 还是 1，如果是 0，则结果不变（就是上面 31 的例子），如果是 1 则运行结果左边会多出一个 1 出来。

按照上面的例子当扩容之后的 `length-1` 到这个位置的时候，位置就会变化：

[![hash_result3.png](http://www.qxnekoo.cn:8888/images/2020/04/29/hash_result3.png)](http://www.qxnekoo.cn:8888/image/MKJU)

那个位置是 127 的位置，也就是说扩容为 128 时，这个字符串对应的哈希桶的位置会发生变化，将 31 改为 127，验证一下：

![hash_result4.png](http://www.qxnekoo.cn:8888/images/2020/04/29/hash_result4.png)

哈希桶的位置变为 74，也就是 10+64=74，这个 64 就是扩容为 128 之前的大小了，这一切就呼应上了。

**这就是为啥 `jdk8` 中扩容时，不需要重新计算 `hash` 值的原理了。**

原理有了，其实在源码中也是能找到相应的实现代码的：resize()方法

![Map.png](http://www.qxnekoo.cn:8888/images/2020/04/29/Map.png)

当然，它的具体实现方式肯定是有一套算法的了。（其实就是我没多大看懂代码具体咋实现的，而且我这边也没有讨论红黑树的情况！！）



下面列举一下 `jdk7` 与 `jdk8` 之间的差异了：

| 不同                       | JDK1.7                                                       | JDK1.8                                                       |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存储结构                   | 数组+链表                                                    | 数组+链表+红黑树                                             |
| 初始化方式                 | 单独函数：inflateTable()                                     | 直接继承到了扩容函数resize()中                               |
| hash值计算方式             | 扰动处理=9次扰动=4次位运算+5次异或运算                       | 扰动处理=2次扰动=1次位运算+1次异或运算                       |
| 存放数据的规则             | 头插法（先讲原位置的数据移到后一位，再插入数据到该位置）     | 尾插法（直接插入到链表尾部、/红黑树）                        |
| 扩容后存储位置的计算法方式 | 全部按照原来方法进行计算（即hashCode->>扰动函数->>(h&length-1)） | 按照扩容后的规律计算（即扩容后的位置=原位置or原位置+旧容量） |