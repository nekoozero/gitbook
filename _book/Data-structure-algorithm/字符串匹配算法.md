# 字符串匹配算法

主串：aaaaaab

模式串：aab

最常见的就是 BF 算法（暴力算法）,假设主串的长度是m,模式串的长度是n，那么在这种极端情况下，BF 算法的最坏时间复杂度为 O(mn)

## RK算法

相对于逐个字符比较两个字符串，仅比较两个字符串的 hashcode 要容易的多。

![](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqcfqkJAelmFZx1RB4CtdUsATggmlE4IibVUcxoZNib1tc6L6It66hMibJHpjoZdQok0pnYkmDKINnVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

生成 hashcode 的算法很多样，比如：

- 按位相加

  a=>1,b=>2,c=>3 然后把所有的字符串相加，结果就是 hashcode。

  bce = 2+3+5 =10

  算法简单，但是可能产生 hash 冲突，比如 bec,bce,ceb 的 hashcode 是一样的。

- 转换成 26 进制数

  把每一个字符串当成一个 26 进制数来计算

  bce = 2*(26^2) + 3*26 + 5 = 1435

  大幅减少了 hash 冲突，但计算量很大，可能出现超出整型范围的情况，需要的结果进行取模。

### 算法设计

> 这里先选择按位相加的 hash 算法.

主串通常长于模式串，把整个主串转换成 hashcode 是没有意义的，只有比较**主串当中和模式串等长的子串才有意义**。

![图片](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqcfqkJAelmFZx1RB4CtdUso8X5icU4fvtt1K3fOxTvgXSK2TicgyEE6oGEibBePH0sD6HVEgRhbSsQA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

不匹配就找下一个子串，直到找到下一个hash值相等的子串。

![图片](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqcfqkJAelmFZx1RB4CtdUsibypRa20QoDG6Wp2PjonjAWwKQ8SSSiaqGoGic3A9h9BHMrnrGmDgECCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

如果找到了，还需要考虑 hash 冲突的场景，所以需要继续比较模式串和子串中的字符（BF 算法）。类似于 HashMap 的冲突，先比较 hashCode，在通过 equals 方法比较。

> 每次 hash 的时间复杂度为 O(n)，如果全部字串都进行 hash，总的时间复杂度就和 BF 算法一样，都是 O(mn)？
>
> 是的，所以计算子串的 hash 值并不是独立的，从第二个子串开始，每一个子串的 hash 都可以由上一个子串进行简单的增量计算来得到。

### 代码实现

```java
package leetcode.common.classic.string;

/**
 * RK 算法
 *
 * @author qianxin
 * @date 2021/05/21
 */
public class RabinKarp {
    public static void main(String[] args) {
        String str = "aacdesadsdfer";
        String pattern  = "adsd";
        System.out.println(rabinKarp(str, pattern));
    }

    public static int rabinKarp(String str, String pattern) {
        int m = str.length();
        int n = pattern.length();
        int patternHash = hash(pattern);
        int strCode = hash(str.substring(0, n));
        for (int i = 0; i < m - n + 1; i++) {
            if (strCode == patternHash && compareString(i, str, pattern)) {
                return i;
            }
            //如果不是最后一轮，更新主串从i到i+n的hash值
            if (i < m - n) {
                strCode = nextHash(str, strCode, i, n);
            }
        }
        return -1;
    }

    private static int hash(String str) {
        int hashcode = 0;
        for (int i = 0; i < str.length(); i++) {
            hashcode += str.charAt(i) - 'a';
        }
        return hashcode;
    }

    private static int nextHash(String str, int hash, int index, int n) {
        hash -= str.charAt(index) - 'a';
        hash += str.charAt(index + n) - 'a';
        return hash;
    }

    private static boolean compareString(int i, String str, String pattern) {
        String strSub = str.substring(i, i + pattern.length());
        return strSub.equals(pattern);
    }
}
```

RK 算法计算单个子串的 hash 的时间复杂度是 O(n)，但由于后续的子串 hash 是增量计算，所以总的时间复杂度仍然是 O(n)。

缺点就是哈希冲突，每一次哈希冲突的时候，RK 算法都要对子串和模式串进行逐个字符的比较，如果冲突太多了，RK 算法就退化成了 BF 算法。













