## 运行时数据区域

虚拟机在执行`Java`程序的时候会把他所管理的内存划分为若干个不同的数据区域，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而自动建立和销毁。

![JVM_RUNTIME_MEMORY.png](http://www.qxnekoo.cn:8888/images/2020/03/11/JVM_RUNTIME_MEMORY.png)

* 程序计数器（`Program Counter Register`）
* Java虚拟机栈(`Java Virtual Machine Stack`)
* 本地方法栈(`Native Method Stacks`)
* Java堆(`Java Heap`)
* 方法区(`Method Area`)
* 运行时常量池(`Runtime Constant Pool`) [是方法区的一部分]
* 直接内存(`Direct Memory`)[不是规范定义的内存区域，但会被频繁使用]

### 程序计数器

较小的一块内存空间，可以看作是当前线程所执行的**字节码的行号指示器**，字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令，是**程序控制流的指示器**，*分支、循环、跳转、异常、线程恢复*等基础功能都要依赖这个计数器来完成。

每条线程都需要一个独立的程序计数器，各条线程之间计数器不影响，独立存储，这类内存区域为“线程私有”的内存。

### Java虚拟机栈

虚拟机栈描述的是`Java`方法执行的线程内存模型：每个方法被执行的时候，`Java`虚拟机都会同步创建一个栈帧（`Stack Frame`）用于**存储局部变量表**、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。它也是线程私有的，生命周期与线程相同。

#### 局部变量表

其中最主要的还是局部变量表这一部分。它存放了编译期可知的各种`Java`虚拟机基本数据、对象引用和`returnAddress`类型。

这些数据类型在局部变量表中的存储空间以局部变量槽（`Slot`）来表示，其中`64`位长度的`long`和`double`类型的数据会占用两个变量槽，其余的数据类型只会占用一个。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在**栈帧中分配多大的局部变量空间是完全确定的**，在方法运行期间不会改变局部变量表的大小（指的是局部变量槽的数量，一个`slot`占多大的空间是由虚拟机自行决定的）。

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常，比如递归。

### 本地方法栈

和虚拟机栈发挥的作用非常相似，区别：**虚拟机栈为虚拟机执行`Java`方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（`Native`）方法服务。**

`HotSpot`虚拟机将本地方法栈和虚拟机栈合二为一。

### `Java`堆

虚拟机管理内存最大的一块，**被所有线程共享的一块内存区域**。虚拟机规范中表明：“所有的对象实例以及数组都应当在堆上分配”。但目前从“实现”的角度上来看，由于即时编译技术的进步，逃逸分析、栈上分配等等已经导致一些微妙的变化发生，所以说对象实例都在堆上分配也不是那么绝对。

**从回收内存的角度来看**，它是垃圾收集器管理的内存区域，由于现代大部分垃圾收集器都是基于**分代收集理论**设计的，所以`Java`堆中经常会出现“新生代”、“老年代”、“Eden空间”、“From Survivor空间”、“To Survivor空间”（以后会细讲）。但其实到今天，即使是`HotSpot`里面也出现了不采用分代设计的新垃圾收集器。

**从分配内存的角度来看**，所有线程共享的堆内存中可以划分出多个**线程私有的分配缓冲区**（`Thread Local Allocation Buffer,TLAB`）,以提升对象分配时的效率。

无论从哪个角度、如何划分，`Java`堆细分的目的只是为了**更好地回收内存，或者更好的分配内存**。

`Java`堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象（比如说数组对象），很可能会要求连续的内存空间。

堆无法扩展时，虚拟机会抛出`OutOfMemoryError`异常。

### 方法区

是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。`JVM`规范中把方法去描述为堆的一个逻辑部分。其实物理上也是一块连续的内存。

在`java8`之前,`HotSpot`虚拟机使用永久代来实现方法区，使得垃圾收集器能够像管理`Java`堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但对于其他虚拟机来说是不存在永久代的概念的。

到`jdk7`的时候，已经把放在永久代的额字符串常量池、静态变量等移出，而到了`jdk8`,则完全废弃了永久代的概念，把剩余的内容（主要是类型信息）全部移到元空间中去。

相对而言，这个区域的垃圾收集行为是比较少出现的。回收目标主要是针对常量池的回收和对类型的卸载，尤其是内存的卸载，效果比较难令人满意。

如果方法区无法满足新的内存分配需求时，将抛出`OutOfMemoryError`异常。

### 运行时常量池

是方法区的一部分，`Class`文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池表（`Constatn Pool Table`），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

当常量池无法再申请到内存时会抛出`OutOfMemoryError`异常。

### 直接内存

并不是虚拟机运行时数据区的一部分，也不是`JVM`规范的内存区域，但这部分内存也被频繁使用，而且也可能导致`OutOfMemoryError`异常出现。

`NIO`是一种基于通道（`Channel`）与缓冲区（`Buffer`）的`I/O`方式，它可以是使用`Native`函数库直接分配堆外内存，然后通过一个存储在`Java`堆里面的`DirectByteBuffer`对象作为这块内存的引用进行操作。

本机直接内存不会受到`Java`堆大小的限制，但是，肯定会受到本机总内存大小以及处理器寻址空间的限制。如果各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现`OutOfMemoryError`异常。